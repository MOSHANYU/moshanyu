[{"title":"设计模式六大原则","date":"2018-07-31T17:55:58.000Z","path":"2018/08/01/设计模式六大原则/","text":"1.单一职责原则 不要存在多于一个导致类变更的原因。 2.里氏替换原则 子类可以扩展父类的功能，但不能改变父类原有的功能。 3.依赖倒置原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。 4.接口隔离原则 客户端不应该被强迫地依赖那些根本用不上的方法。 5.迪米特原则 一个对象应该对其他对象保持最少的了解【在一个类中应该少出现其他类】。 6.开闭原则 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://msyblog.top/tags/设计模式/"}]},{"title":"同步和异步 阻塞和非阻塞","date":"2018-07-29T17:30:13.000Z","path":"2018/07/30/同步和异步 阻塞和非阻塞/","text":"同步：调用者主动等待调用的结果；异步：调用者可能不会立即得到结果，需要被调用者通过状态、通知来通知调用者，或者通过回调函数处理这个调用。 当你去面试后，主动询问或等待面试结果，这个就是同步；你完成面试之后，HR说结果不能马上出来，你先回去等通知哈，过不久后HR打电话或发短信跟你说面试结果，这个就是异步。 也就是说，同步和异步的区别就是主动获取和被动获取的区别，阻塞和非阻塞的区别就是在获取到反馈之前，你能不能干其它的事情。 参考链接（侵删）* https://www.cnblogs.com/Anker/p/5965654.html","tags":[{"name":"同步","slug":"同步","permalink":"https://msyblog.top/tags/同步/"},{"name":"异步","slug":"异步","permalink":"https://msyblog.top/tags/异步/"},{"name":"阻塞","slug":"阻塞","permalink":"https://msyblog.top/tags/阻塞/"},{"name":"非阻塞","slug":"非阻塞","permalink":"https://msyblog.top/tags/非阻塞/"}]},{"title":"设计模式之单例模式","date":"2018-07-29T16:20:14.000Z","path":"2018/07/30/设计模式之单例模式/","text":"什么是单例模式 单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中，应用该模式的类一个类只有一个实例。即一个类只有一个对象实例。 单例模式可分为懒汉模式，饿汉模式和登记式单例模式。 单例模式的特点 单例模式只能有一个实例 单例类必须创建自己的唯一实例 单例类必须给其他对象提供这一实例 私有构造函数 私有的静态的全局变量 公有的静态的方法 常见的单例模式例子 线程池 缓存 日志对象 对话框 spring的controller 自定义的HibernateUtil在获取SessionFactory时使用单例 单例模式的Java实现懒汉模式非线程安全的懒汉模式12345678910111213public class SingleTonLazyLoadUnsafety &#123; private static SingleTonLazyLoadUnsafety instance; private SingleTonLazyLoadUnsafety()&#123;&#125; public static SingleTonLazyLoadUnsafety getInstance() &#123; if (instance == null) &#123; instance = new SingleTonLazyLoadUnsafety(); &#125; return instance; &#125;&#125; 双检锁加volatile [ˈvɒlətaɪl]实现线程安全的懒汉模式1234567891011121314151617public class SingletonLazyLoadSafety &#123; private volatile static SingletonLazyLoadSafety instance; private SingletonLazyLoadSafety()&#123;&#125; public static SingletonLazyLoadSafety getInstance() &#123; if (instance == null) &#123; synchronized (SingletonLazyLoadSafety.class) &#123; if (instance == null) &#123; instance = new SingletonLazyLoadSafety(); &#125; &#125; &#125; return instance; &#125;&#125; 通过synchronized实现线程同步，volatile防止系统进行指令重排序，这两个关键字是必不可少的。如果不加上volatile，在instance = new SingletonLazyLoadSafety()这段代码中可能会出现指令重排序，线程获取到的实例可能会是空值。具体参考https://www.jianshu.com/p/17ed6a46ed85。 饿汉模式实现1234567891011public class SingletonHungary &#123; private static SingletonHungary instance = new SingletonHungary(); private SingletonHungary() &#123;&#125; public static SingletonHungary getInstance() &#123; return instance; &#125;&#125; 也可以在静态代码块中初始化instance，效果差不多。 枚举实现单例模式1234567891011121314151617181920public class EnumSingleton &#123; public static EnumSingleton getInstance() &#123; return Singleton.INSTANCE.getInstance(); &#125; private static enum Singleton &#123; INSTANCE; private EnumSingleton instance; private Singleton() &#123; instance = new EnumSingleton(); &#125; public EnumSingleton getInstance() &#123; return instance; &#125; &#125;&#125; 实现登记式单例模式1234567891011121314151617181920212223242526272829303132333435363738394041public class RegisterSingleton &#123; private static Map&lt;String, RegisterSingleton&gt; singletons = new ConcurrentHashMap&lt;&gt;(); static &#123; RegisterSingleton registerSingleton = new RegisterSingleton(); singletons.put(registerSingleton.getClass().getName(), registerSingleton); &#125; // 保护默认构造函数 protected RegisterSingleton() &#123; &#125; // 静态工厂方法，返回此类的唯一实例 public static RegisterSingleton getInstance(String name) &#123; if (name == null || name.trim().length() &lt; 1) &#123; name = RegisterSingleton.class.getName(); &#125; if (singletons.get(name) == null) &#123; try &#123; singletons.put(name, (RegisterSingleton) Class.forName(name).newInstance()); &#125; catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; return singletons.get(name); &#125;&#125;--------------------------------------------------------------------------------public class ChildOfRegisterSingleton extends RegisterSingleton &#123;// private ChildOfRegisterSingleton() &#123;&#125; 这个不能加，加了会报错，不能反射 public static ChildOfRegisterSingleton getInstance() &#123; System.out.println(\"getInstance --&gt; \"+RegisterSingleton.class.getName()); return (ChildOfRegisterSingleton) RegisterSingleton.getInstance(ChildOfRegisterSingleton.class.getName()); &#125; public static String getHashCode() &#123; return \"hashCode:\"+getInstance().hashCode(); &#125;&#125; 相当于有一个容器装载所有实例，在实例产生之前先检查下容器有没有，如果有就直接取出来，如果没有就先new一个放进去，然后给后面的人用，Spring的IOC容器就是一种注册登记式单例。 登记式单例实际上维护了一种单例类的实例，将这些实例存放在一个Map中，对于已经登记过的实例，则从Map直接返回，没有登记的，则先登记，然后返回。 登记式单例内部实现其实还是用的饿汉式，因为其中的static方法块，它的的单例在类被装载时就被实例化了。 参考链接（侵删） https://www.cnblogs.com/Ycheng/p/7169381.html https://www.cnblogs.com/yangzhilong/p/6148639.html https://blog.csdn.net/qq_36413562/article/details/78768155","tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://msyblog.top/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"https://msyblog.top/tags/单例模式/"}]},{"title":"晶体三极管基础符号及公式","date":"2018-06-13T14:52:39.000Z","path":"2018/06/13/晶体三极管/","text":"BJT：双极型晶体管; 基区：很薄且掺杂浓度很低； 集电区：面积很大 发射区： 掺杂浓度很高 发射区与基区间的PN结称为发射结，基区与集电区的PN结称为集电结。 放大是对模拟信号最基本的处理 晶体管是放大电路的核心元件 共射放大电路：基极-发射极回路为输入回路；放大后的信号在集电极-发射极回路，称为输出回路。由于发射极是两个电路的公共端，故称该电路为共射放大电路。 使晶体管工作在放大状态的外部条件是发射结正偏且集电结反偏。因而在输入回路需加基极电源$V_{BB}$；在输出回路需加集电极电源$V_{CC}$；$V_{CC}$应大于$V_{BB}$。 晶体管的放大作用表现为小的基极电流可以控制大的集电极电流。 发射结加正向电压，由于浓度差产生的扩散运动形成发射极电流$I_E$ 扩散到基区的自由电子与空穴的复合运动形成基极电流$I_B$。由于基区很薄，杂质浓度很低，集电结又加了反向电压，所以扩散到基区的电子中只有少部分与空穴复合，其余部分均作为基区的非平衡少子达到集电结。又由于电源$V_{BB}$的作用，电子与空穴的复合运功将源源不断地进行，形成基极电流$I_B$。 集电结加反向电压，漂移运动形成集电极电流$I_C$。由于集电结加反向电压且其结面积较大，基区的非平衡少子（也就是从发射极跑过来的部分电子）在外电场作用下越过集电结到达集电区，形成漂移电流。与此同时，集电区与基区的平衡少子也参与漂移运动，但它的数量很小，近似分析中可忽略不计。可见，在集电极电源$V_{CC}$的作用下，漂移运动形成集电极电流$I_C$。 $I_{EN}$：由发射区向基区扩散形成的电子电流 $I_{EP}$：基区向发射区扩散所形成的空穴电流 $I_{BN}$：基区内复合运动形成的电流 $I_{CN}$：基区内非平衡少子漂移到集电区所形成的电流 $I_{CBO}$：平衡少子在集电区与基区之间的漂移运动所形成的电流（在$V_{CC}$作用下）。 $I_E$=$I_{EN}$+$I_{EP}$=$I_{CN}$+$I_{BN}$+$I_{EP}$ $I_C$=$I_{CN}$+$I_{CBO}$ $I_B$=$I_{BN}$+$I_{EP}$-$I_{CBO}$ $I_E$=$I_C$+$I_B$","tags":[{"name":"晶体三极管","slug":"晶体三极管","permalink":"https://msyblog.top/tags/晶体三极管/"},{"name":"模电","slug":"模电","permalink":"https://msyblog.top/tags/模电/"}]},{"title":"java关于i++和++i一段很有意思的代码","date":"2018-06-10T08:16:27.000Z","path":"2018/06/10/java关于i-和-i一段很有意思的代码/","text":"读完本篇文章可以基本了解Java中的i++以及++i…1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int a = 0;a = ++a + a++;// a=1+1System.out.println(\"a=\" + a);int b = 0;b = b++ + ++b;// b=0+(1+1)System.out.println(\"b=\" + b);int c = 0;c = c++ + c;// c=0+1System.out.println(\"c=\" + c);int d = 0;d = ++d + d;// d=1+1System.out.println(\"d=\" + d);int e = 0;e = ++e + ++e;// e=1+2System.out.println(\"e=\" + e);int f = 0;f = f++ + f++;// f= 0+1System.out.println(\"f=\" + f);int g = 0;int h;g = g++;// g=0System.out.println(\"g=\" + g);g = g++;// g=0System.out.println(\"g=\" + g);h = g++;// h=0 g=1System.out.println(\"g=\" + g + \",h=\" + h);int i = 0;i = i++ + 2; // i=0+2System.out.println(i);int j = 0;j = ++j + 2;// j=1+2System.out.println(j);int x = 9;int y = 10;int z;z = (++x == y) ? ++x : y--;//++x;++x;z=11;System.out.println(\"x=\" + x + \",y=\" + y + \",z=\" + z);int m = 0;boolean b1 = m++ == 1;// falseboolean b2 = m++ == 1 || m == 1;// true","tags":[{"name":"java","slug":"java","permalink":"https://msyblog.top/tags/java/"},{"name":"i++","slug":"i","permalink":"https://msyblog.top/tags/i/"},{"name":"++i","slug":"i","permalink":"https://msyblog.top/tags/i/"},{"name":"代码","slug":"代码","permalink":"https://msyblog.top/tags/代码/"}]},{"title":"MVVC机制","date":"2018-06-07T15:26:25.000Z","path":"2018/06/07/MVVC机制/","text":"什么是MVVC MVVC全称为Multiversion Concurrency Control，也就是多版本并发控制。 MVVC就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。 Mysql只有read-committed和 repeatable-read 两种事务隔离级别才能使用MVCC。 MVVC有什么用 Mysql可以通过MVVC来解决幻读问题。","tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://msyblog.top/tags/Mysql/"},{"name":"事务","slug":"事务","permalink":"https://msyblog.top/tags/事务/"},{"name":"MVVC","slug":"MVVC","permalink":"https://msyblog.top/tags/MVVC/"},{"name":"幻读","slug":"幻读","permalink":"https://msyblog.top/tags/幻读/"}]},{"title":"什么是幻读","date":"2018-06-07T15:12:42.000Z","path":"2018/06/07/什么是幻读/","text":"什么是幻读 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之前，任何人都不能将新材料添加到文档中，则可以避免该问题。 再举个例子，事务T1先是查询ID为1的用户存不存在，如果不存在则插入一条ID为1的数据，事务T1查询发现数据库中没有该用户，准备插入数据，这时候有个事务T2比T1先执行了【插入ID为1的用户数据】，所以在T1执行插入数据时会报主键冲突。 幻读的解决方式 Mysql可以使用MVVC方式解决幻读。","tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://msyblog.top/tags/Mysql/"},{"name":"事务","slug":"事务","permalink":"https://msyblog.top/tags/事务/"},{"name":"MVVC","slug":"MVVC","permalink":"https://msyblog.top/tags/MVVC/"},{"name":"幻读","slug":"幻读","permalink":"https://msyblog.top/tags/幻读/"}]},{"title":"脏读","date":"2018-06-07T15:09:55.000Z","path":"2018/06/07/什么是脏读/","text":"脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。","tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://msyblog.top/tags/Mysql/"},{"name":"事务","slug":"事务","permalink":"https://msyblog.top/tags/事务/"},{"name":"脏读","slug":"脏读","permalink":"https://msyblog.top/tags/脏读/"}]},{"title":"Mysql事务","date":"2018-06-07T14:34:27.000Z","path":"2018/06/07/Mysql事务/","text":"什么是事务（Transaction） 事务是应用程序中一系列严密的操作，所有操作要么全部成功，要么什么都不做。 事务的四个特性（ACID） A（Atomicity）原子性：一个事务的执行被视为一个不可分割的最小单元。事务里面的操作，要么全部成功执行，要么全部失败回滚（Rollback），不可以只执行其中的一部分。 C（Consistency）一致性：事务开始之前和结束之后，数据库的完整性不能被破坏。比如说A给B转账1000元，在A账户减去1000元后系统故障，此时必须保证A和B账户的总额是和转账前相等的。 I（Isolation）隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（Read committed）、可重复读（Repeatable read）和串行化（Serializable）。后面会对数据库隔离性作相关的总结。 D(durability)持久性：事务提交后，对数据的修改就是永久的，即使系统故障也不会丢失。 事务的四种隔离级别读未提交（Read uncommitted） 事务中的修改，即使没有提交，在其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读，很少用。 读提交（Read committed） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 可重复读（Repeatable read） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 串行化（Serializable） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 MVVC机制 MVVC全称为Multiversion Concurrency Control，也就是多版本并发控制。前面说过Mysql的默认隔离级别为可重复读（Repeatable read），在这个隔离级别中会出现幻读的问题，而MVVC机制就是解决幻读的一个方法。 什么是多版本并发控制呢 ？其实就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。 只有read-committed和 repeatable-read 两种事务隔离级别才能使用MVCC。 read-uncommited由于是读到未提交的，所以不存在版本的问题，而serializable 则会对所有读取的行加锁。","tags":[{"name":"Mysql","slug":"Mysql","permalink":"https://msyblog.top/tags/Mysql/"},{"name":"事务","slug":"事务","permalink":"https://msyblog.top/tags/事务/"},{"name":"隔离级别","slug":"隔离级别","permalink":"https://msyblog.top/tags/隔离级别/"},{"name":"MVVC","slug":"MVVC","permalink":"https://msyblog.top/tags/MVVC/"},{"name":"幻读","slug":"幻读","permalink":"https://msyblog.top/tags/幻读/"},{"name":"转载","slug":"转载","permalink":"https://msyblog.top/tags/转载/"}]},{"title":"模电考试安排","date":"2018-06-07T14:11:43.000Z","path":"2018/06/07/模电考试安排/","text":"如图，7月8号上午9点半到11点半","tags":[{"name":"模电","slug":"模电","permalink":"https://msyblog.top/tags/模电/"},{"name":"考试","slug":"考试","permalink":"https://msyblog.top/tags/考试/"}]},{"title":"第一章 常用半导体器件","date":"2018-06-04T06:16:28.000Z","path":"2018/06/04/第一章 常用半导体器件/","text":"1.1 半导体基础知识1.1.1 本征半导体 纯净的具有晶体结构的半导体称为本征半导体 物质的导电性能决定于原子结构 半导体三个特性：温度，杂质，光度 晶体中的原子在空间形成排列整齐的点阵，称为晶格 共用电子 共价键【关键词，也许填空题会考】 自由电子、空穴在晶体中能自由移动 本征半导体中电流等于电子电流加上空穴电流 在电场作用下，自由电子与空穴运动方向相反，但对电场作用叠加 运载电荷的粒子称为载流子 半导体在热激发下产生自由电子和空穴对的现象称为本征激发 自由电子填补空穴称为复合 动态平衡 1.1.2 杂质半导体 在本征半导体中掺入少量合适的杂质元素，便可得到杂质半导体，按掺入的杂质元素不同，可形成N型半导体和P型半导体 在纯净的硅晶体中掺入五价元素（如磷），使之取代晶格中硅原子的位置，就形成了N型半导体，掺入三价元素，形成P型半导体 N型半导体中的多子为自由电子，杂质原子在晶格上形成不能移动的正离子，由于杂质原子可以提供电子，故称之为施主原子 P型半导体中的多子为空穴，杂质原子成为不可移动的负离子，由于杂质原子中的空位吸收电子，故称之为受主原子 1.1.3 PN结 采用不同的掺杂工艺，将P型半导体与N型半导体制作在同一块硅片上，在它们的交界面就形成PN结，PN结具有单向导电性 PN结的形成 由浓度差产生的运动称为扩散运动 空间电荷区 随着扩散运动的进行，空间电荷区加宽，内电场增强，其方向由N区指向P区，正好阻止扩散运动的进行。 在电场力作用下，载流子的运动称为漂移运动。 在无外电场和其它激发作用下，参与扩散运动的多子数目等于参与漂移运动的少子数目，从而达到动态平衡，形成PN结，此时，空间电荷区具有一定的宽度，电位差为$U_{ho}$，电流为零。空间电荷区内，正、负电荷的电量相等；因此，当P区与N区杂质浓度相等时，负离子区与正离子区的宽度也相等，称为对称结；而当两边杂质不同时，浓度高一侧的离子区宽度低于浓度低的一侧，称为不对称PN结，两种结的外部特性是相同的 绝大部分空间电荷区内自由电子和空穴都非常少，在分析PN结特性时常忽略载流子的作用，而只考虑离子区的电荷，这种方法称为“耗尽层近似”，故也称空间电荷区为“耗尽层”（也称为势垒区或阻挡层） 如果在PN结的两端外加电压，就将破坏原来的平衡状态。此时，扩散电流就不再等于漂移电流，因而PN结将有电流流过。 PN结的单向导电性 当外加电压极性不同时，PN结表现出截然不同的导电性能，即呈现出单向导电性(正偏导通，反偏截止) PN结正偏： 当PN结正偏时（即外加电源正极接到P端，负极接到N端），在外电场的作用下，分别将P端和N端的多子推向空间电荷区【这个是不是也算漂移运动，因为这也是在电场力作用下的载流子运动？或者称为多子的漂移运动】，使空间电荷区变窄，削弱了内电场，破坏了原来的平衡，使扩散运动加剧，漂移运动减弱【少子的漂移运动减弱】。由于电源的作用，扩散运动将源源不断地进行，从而形成正向电流，PN结导通。 PN结导通时的电压降只有零点几伏，因而应该在它所在的回路中串联一个电阻，以限制回路的电流，防止PN结因正向电流过大而损坏 PN结反偏： 当PN结反偏时，外电场使空间电荷区变宽，加强了内电场，阻止扩散运动的进行，而加剧漂移运动的进行，形成反向电流，也称为漂移电流。由于少子极少，反向电流非常小，在近似分析中常将它忽略不计，认为PN结外加反向电压时处于截止状态。 PN结的电流方程 PN结所加端电压u与流过它的电流i的关系为： $i=I_s(e^{qu \\over kt}-1)$ （1.1.2） （1.1.2）式中$I_s$为反向饱和电流，q为电子的电量，k为玻尔兹曼常数，T为热力学温度。将式中的kT/q用$U_T$取代，则得 $i=I_s(e^{u \\over U_T}-1)$ （1.1.3） 常温下，即T=300K时，$U_T$≈26mV PN结的伏安特性 当PN结外加正向电压，且u&gt;&gt;$U_T$时，$i≈I_se^{u \\over U_T}$，即i随u按指数规律变化；当PN结外加反向电压，且|u|&gt;&gt;$U_T$时，$i≈-I_s$ 画出i与u的关系曲线如图所示： ，称为PN结的伏安特性。其中u&gt;0的部分为正向特性，u&lt;0的部分称为反向特性。 当反向电压超过一定数值$U_{(BR)}$后，反向电流急剧增加，称之为反向击穿。 反向击穿按机理分为齐纳击穿和雪崩击穿两种情况。 齐纳击穿：高掺杂情况下，因耗尽层【也称空间电荷区】宽度很窄，不大的反向电压就可以在耗尽层形成很强的电场，而直接破坏共价键，使价电子脱离共价键束缚，产生电子-空穴对，致使电流急剧增大，这种击穿称为齐纳击穿。 雪崩击穿：掺杂浓度低，耗尽层较宽，低电压下不会产生齐纳击穿。当反向电压增加到较大数值时，耗尽层的电场使少子加快漂移速度，从而与共价键中的价电子相碰撞，把价电子撞出共价键，产生电子-空穴对。新产生的电子与空穴被电场加速后又撞出其它价电子，载流子雪崩式地倍增，致使电流急剧增加，这种击穿称为雪崩击穿。 PN结的电容效应 在一定条件，PN结具有电容效应，根据产生原因不同分为势垒电容和扩散电容 势垒电容：当PN结外加电压变化时，空间电荷区的宽度将随之变化，即耗尽层的电荷量随外加电压而增大或减小，这种现象与电容器的充放电过程相同。耗尽层宽窄变化所等效的电容称为势垒电容$C_b$。$C_b$具有非线性，它与结面积、耗尽层宽度、半导体的介电常数及外加电压有关。 下图为势垒电容$C_b$与外加电压u的关系： PN结处于平衡状态时的少子常称为平衡少子。PN结处于正向偏置时，从P区扩散到N区的空穴和从N区扩散到P区的自由电子均称为非平衡少子。&nbsp;&nbsp;&nbsp;&nbsp;当外加正向电压一定时，靠近耗尽层交界面的地方非平衡少子的浓度高，而远离交界面的地方浓度低，且浓度自高到底逐渐衰减，直到零。形成一定的浓度梯度【即浓度差】，从而形成扩散电流。当正向外加电压增大时，非平衡少子的浓度增大且浓度梯度也增大，从外部看正向电流（即扩散电流）增大。当外加正向电压减小时与上述变化相反。 扩散区内，电荷的积累和释放过程中与电容器充放电过程相同，这种电容效应称为扩散电容$C_d$。和$C_b$一样，$C_d$也具有非线性，它与流过PN结的争相电流i、温度的电压当量$U_T$以及非平衡少子的寿命τ有关。i越大、τ越大、$U_T$越小，$C_d$寿命就越大。 由此可见，PN结的结电容$C_j$是$C_b$与$C_d$之和，即$C_j$=$C_b$+$C_d$ 由于$C_b$与$C_d$一般都很小，对于低频信号呈现出很大的容抗，其作用可忽略不计，因此只有在信号频率较高时才考虑结电容的作用。 1.2 半导体二极管 将PN结用外壳封装起来，并加上电极引线就构成了半导体二极管，简称二极管。 1.2.1 二极管的几种常见结构 点接触型二极管由一根金属丝经过特殊工艺与半导体表面相接形成PN结。因而结面积小，不能通过较大的电流。但其结电容较小，因此适用于高频电路和小功率整流。 面接触型二极管是采用合金法工艺制成的。结面积大，能够通过较大的电流，但其结电容大，因而只能在较低频率下工作，一般仅作为整流管。 平面二极管是采用扩散法制成的。结面积较大的可用于大功率整流，结面积小的可作为脉冲数字电路中的开关管。 1.2.2 二极管的伏安特性二极管和PN结伏安特性的区别 与PN结一样，二极管具有单向导电性。但是，由于二极管存在半导体体电阻和引线电阻，所以在外加正向电压时，在电流相同的情况下，二极管的端电压大于PN结上的压降；或者说，①在外加电压相同的情况下，二极管的正向电流要小于PN结的电流；在大电流的情况下，这种情况更为明显。另外，由于二极管表面漏电流的存在，使外加反向电压时的反向电流增大。 在近似分析时，仍然用PN结的电流方程式（1.1.2）、（1.1.3）来描述二极管的伏安特性。 实测二极管的伏安特性时发现，②只有在正向电压足够大时，正向电流才从零端随电压按指数规律增大。使二极管开始导通的临界电压称为开启电压$U_{on}$，如图所示： 当二极管所加反向电压的数值足够大时，反向电流为$I_s$。反向电压太大使二极管击穿。 由于硅材料PN结平衡时耗尽层电势$U_{ho}$比锗材料的大，使得硅材料的$U{on}$比锗材料的大。温度对二极管伏安特性的影响 在环境温度升高时，二极管的正向特性曲线将左移，反向特性曲线将下移。二极管的特性对温度很敏感。 1.2.3 二极管的主要参数 为描述二极管的性能，常引用如下几个参数：最大整流电流$I_F$、最高反向工作电压$U_R$、反向电流$I_R$，最高工作频率$f_M$。 最大整流电流$I_F$是二极管长期运行时允许通过的最大正向平均电流，其值与PN结面积及外部散热条件等有关。 最高反向工作电压$U_R$是二极管工作时允许外加的最大反向电压。 反向电流$I_R$是二极管未击穿时的反向电流，$I_R$越小，二极管的单向导电性越好，$I_R$对温度非常敏感。 最高工作频率$f_M$是二极管的工作上限截止频率。超过此值时，由于结电容的作用，二极管将不能很好地体现出单向导电性。 1.2.4 二极管的等效电路 能够模拟二极管特性的电路称为二极管的等效电路，也称为二极管的等效模型。","tags":[{"name":"模电","slug":"模电","permalink":"https://msyblog.top/tags/模电/"},{"name":"电路","slug":"电路","permalink":"https://msyblog.top/tags/电路/"},{"name":"半导体","slug":"半导体","permalink":"https://msyblog.top/tags/半导体/"},{"name":"二极管","slug":"二极管","permalink":"https://msyblog.top/tags/二极管/"},{"name":"伏安特性","slug":"伏安特性","permalink":"https://msyblog.top/tags/伏安特性/"}]}]